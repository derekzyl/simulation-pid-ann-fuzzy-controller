


%% Electric Automotive Cooling System Simulation with ANN, PID, and FLC Controllers
% This script simulates and compares the performance of three control approaches
% (PID, Fuzzy Logic, and ANN) for regulating the cooling system of an electric vehicle.
% The simulation includes models for water pump dynamics, heat transfer mechanisms,
% and engine temperature regulation.

clear all;
close all;
clc;

%% System Parameters
% Engine and cooling system parameters
params.engine.mass = 150;              	% Engine mass (kg)
params.engine.specific_heat = 450;     	% Specific heat capacity of engine material (J/kg·K)
params.engine.heat_generation_nom = 30000; % Nominal heat generation rate (W)
params.engine.optimal_temp = 90;       	% Optimal engine temperature (°C)
params.engine.max_temp = 110;          	% Maximum allowable engine temperature (°C)
params.engine.ambient_temp = 25;       	% Ambient temperature (°C)

% Water pump parameters
params.pump.max_flow_rate = 2.5;       	% Maximum flow rate (kg/s)
params.pump.min_flow_rate = 0.2;       	% Minimum flow rate (kg/s)
params.pump.max_speed = 3000;          	% Maximum pump speed (RPM)
params.pump.time_constant = 0.5;       	% Pump response time constant (s)

% Radiator parameters
params.radiator.efficiency = 0.85;     	% Radiator heat transfer efficiency
params.radiator.heat_transfer_coeff = 800; % Heat transfer coefficient (W/K)

% Coolant parameters
params.coolant.density = 1000;         	% Coolant density (kg/m³)
params.coolant.specific_heat = 4186;   	% Specific heat capacity of coolant (J/kg·K)
params.coolant.volume = 5;             	% Coolant volume in system (L)

% Simulation parameters
sim_time = 600;                        	% Simulation time (s)
sample_time = 0.1;                     	% Sample time (s)
time = 0:sample_time:sim_time;         	% Time vector
n_samples = length(time);

% Disturbances (to test controller robustness)
% 1. Variable engine load (simulates acceleration/deceleration)
load_profile = ones(1, n_samples);
load_profile(1000:2000) = 1.5;         	% Higher load (150%)
load_profile(3000:4000) = 0.7;         	% Lower load (70%)
load_profile(5000:5500) = 1.8;         	% Very high load (180%)

% 2. Variable ambient temperature
ambient_temp_profile = params.engine.ambient_temp * ones(1, n_samples);
ambient_temp_profile(2000:3500) = params.engine.ambient_temp + 15; % Hot day scenario
ambient_temp_profile(4500:5500) = params.engine.ambient_temp - 10; % Cold day scenario

%% Initialize State Variables
% Engine temperature (°C)
T_engine = params.engine.ambient_temp * ones(1, n_samples);
% Coolant temperature (°C)
T_coolant = params.engine.ambient_temp * ones(1, n_samples);
% Pump flow rate (kg/s)
flow_rate = params.pump.min_flow_rate * ones(1, n_samples);
% Pump speed command (RPM)
pump_speed_command = zeros(1, n_samples);
% Heat generated by engine (W)
heat_generated = zeros(1, n_samples);
% Heat dissipated by radiator (W)
heat_dissipated = zeros(1, n_samples);

%% Controller Setup

% 1. PID Controller
pid.Kp = 150;                          	% Proportional gain
pid.Ki = 15;                           	% Integral gain
pid.Kd = 10;                           	% Derivative gain
pid.error_sum = 0;                     	% Initialize error sum for integral term
pid.last_error = 0;                    	% Initialize last error for derivative term

% 2. Fuzzy Logic Controller Setup
fis = setupFuzzyController();          	% Function to set up fuzzy controller (defined below)

% 3. ANN Controller
% Train ANN controller with sample data
ann = trainANNController(params);      	% Function to train ANN (defined below)

% Control signal outputs for each controller type
control_pid = zeros(1, n_samples);
control_fuzzy = zeros(1, n_samples);
control_ann = zeros(1, n_samples);

% Engine temperature results for each controller
T_engine_pid = params.engine.ambient_temp * ones(1, n_samples);
T_engine_fuzzy = params.engine.ambient_temp * ones(1, n_samples);
T_engine_ann = params.engine.ambient_temp * ones(1, n_samples);

% Power consumption for each controller
power_consumption_pid = zeros(1, n_samples);
power_consumption_fuzzy = zeros(1, n_samples);
power_consumption_ann = zeros(1, n_samples);

%% Run Simulations for Each Controller Type
controllers = {'PID', 'Fuzzy', 'ANN'};

for controller_idx = 1:length(controllers)
	controller_type = controllers{controller_idx};
    
	% Reset initial conditions
	T_engine_current = params.engine.ambient_temp;
	T_coolant_current = params.engine.ambient_temp;
	flow_rate_current = params.pump.min_flow_rate;
	pid.error_sum = 0;
	pid.last_error = 0;
    
	% Simulation loop
	for i = 2:n_samples
    	% Calculate heat generated by engine (affected by load profile)
    	heat_gen = params.engine.heat_generation_nom * load_profile(i-1);
    	heat_generated(i) = heat_gen;
   	 
    	% Calculate heat dissipated by radiator
    	heat_diss = params.radiator.heat_transfer_coeff * (T_coolant_current - ambient_temp_profile(i-1)) * flow_rate_current * params.radiator.efficiency;
    	heat_dissipated(i) = max(0, heat_diss); % Cannot be negative
   	 
    	% Calculate engine temperature change
    	dT_engine = (heat_gen - heat_diss * params.radiator.efficiency) * sample_time /	(params.engine.mass * params.engine.specific_heat);
    	T_engine_current = T_engine_current + dT_engine;
   	 
    	% Apply appropriate controller based on selected type
    	if strcmp(controller_type, 'PID')
        	% PID control
        	error = params.engine.optimal_temp - T_engine_current;
        	pid.error_sum = pid.error_sum + error * sample_time;
        	error_rate = (error - pid.last_error) / sample_time;
        	pid.last_error = error;
       	 
        	% PID output calculation
        	control_output = pid.Kp * error + pid.Ki * pid.error_sum + pid.Kd * error_rate;
       	 
        	% Constrain control output to pump operating range
        	pump_speed = min(max(0, control_output), params.pump.max_speed);
        	control_pid(i) = pump_speed;
       	 
    	elseif strcmp(controller_type, 'Fuzzy')
        	% Fuzzy Logic control
        	error = params.engine.optimal_temp - T_engine_current;
       	 
        	% FIX: Calculate error rate correctly and clamp it to the acceptable range [-10, 10]
        	if i > 2
            	prev_error = params.engine.optimal_temp - T_engine(i-1);
            	error_rate = (error - prev_error) / sample_time;
        	else
            	error_rate = 0;
        	end
       	 
        	% Clamp error_rate to prevent warnings
        	error_rate = max(-10, min(10, error_rate));
       	 
        	% Evaluate fuzzy rules
        	output = evalfis([error, error_rate], fis);
       	 
        	% Scale output to pump speed range
        	pump_speed = output * params.pump.max_speed;
        	control_fuzzy(i) = pump_speed;
       	 
    	elseif strcmp(controller_type, 'ANN')
        	% ANN control
        	% FIX: Prepare inputs for ANN with proper dimensions
        	input_data = [
            	T_engine_current;
            	load_profile(i-1);
            	ambient_temp_profile(i-1)
        	];
       	 
        	% Normalize inputs based on training data ranges
        	normalized_input = (input_data - ann.input_min) ./ (ann.input_max - ann.input_min);
       	 
        	% FIX: Ensure normalized_input matches the expected network input size
        	% Make sure normalized_input is a column vector as expected by the network
        	if size(normalized_input, 1) ~= size(ann.input_min, 1)
            	normalized_input = normalized_input';
        	end
       	 
        	% Get ANN output
        	ann_output = sim(ann.net, normalized_input);
       	 
        	% Denormalize output to get pump speed
        	pump_speed = ann_output * params.pump.max_speed;
        	control_ann(i) = pump_speed;
    	end
   	 
    	% Apply control action (with pump dynamics)
    	if strcmp(controller_type, 'PID')
        	flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
    	elseif strcmp(controller_type, 'Fuzzy')
        	flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
    	elseif strcmp(controller_type, 'ANN')
        	flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
    	end
   	 
    	% Apply first-order pump dynamics
    	flow_rate_current = flow_rate_current + (flow_rate_target - flow_rate_current) *	(1 - exp(-sample_time / params.pump.time_constant));
   	 
    	% Calculate power consumption (proportional to cube of speed)
    	if strcmp(controller_type, 'PID')
        	power_consumption_pid(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
    	elseif strcmp(controller_type, 'Fuzzy')
        	power_consumption_fuzzy(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
    	elseif strcmp(controller_type, 'ANN')
        	power_consumption_ann(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
    	end
   	 
    	% Calculate coolant temperature change
    	coolant_heat_absorbed = heat_gen - heat_diss;
    	dT_coolant = coolant_heat_absorbed * sample_time /  (params.coolant.density * params.coolant.volume * 0.001 * params.coolant.specific_heat);
    	T_coolant_current = T_coolant_current + dT_coolant;
   	 
    	% Store results
    	if strcmp(controller_type, 'PID')
        	T_engine_pid(i) = T_engine_current;
    	elseif strcmp(controller_type, 'Fuzzy')
        	T_engine_fuzzy(i) = T_engine_current;
    	elseif strcmp(controller_type, 'ANN')
        	T_engine_ann(i) = T_engine_current;
    	end
   	 
    	% Store current temperature for the next iteration
    	T_engine(i) = T_engine_current;
    	T_coolant(i) = T_coolant_current;
	end
end

%% Performance Evaluation
% Calculate performance metrics for each controller
metrics = evaluateControllerPerformance(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
                                   	power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
                                   	params.engine.optimal_temp);

%% Visualize Results
plotResults(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
       	control_pid, control_fuzzy, control_ann, ...
       	power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
       	load_profile, ambient_temp_profile, params, metrics);

%% Helper Functions

function fis = setupFuzzyController()
	% Create a new Fuzzy Inference System (FIS)
	fis = mamfis('Name', 'CoolingSystem');  % Corrected usage of mamfis
    
	% Add input variable 'temperature_error'
	fis = addInput(fis, [-30 30], 'Name', 'temperature_error');
	fis = addMF(fis, 'temperature_error', 'trimf', [-30 -20 -10], 'Name', 'negative_large');
	fis = addMF(fis, 'temperature_error', 'trimf', [-15 -5 0], 'Name', 'negative_small');
	fis = addMF(fis, 'temperature_error', 'trimf', [-5 0 5], 'Name', 'zero');
	fis = addMF(fis, 'temperature_error', 'trimf', [0 5 15], 'Name', 'positive_small');
	fis = addMF(fis, 'temperature_error', 'trimf', [10 20 30], 'Name', 'positive_large');
    
	% Add input variable 'error_rate'
	fis = addInput(fis, [-10 10], 'Name', 'error_rate');
	fis = addMF(fis, 'error_rate', 'trimf', [-10 -5 0], 'Name', 'negative');
	fis = addMF(fis, 'error_rate', 'trimf', [-3 0 3], 'Name', 'zero');
	fis = addMF(fis, 'error_rate', 'trimf', [0 5 10], 'Name', 'positive');
    
	% Add output variable 'pump_speed_percentage'
	fis = addOutput(fis, [0 1], 'Name', 'pump_speed_percentage');
	fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0 0.1 0.3], 'Name', 'very_low');
	fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.2 0.4 0.6], 'Name', 'low');
	fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.4 0.6 0.8], 'Name', 'medium');
	fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.6 0.8 0.9], 'Name', 'high');
	fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.8 1 1], 'Name', 'very_high');
    
	% Add fuzzy rules
	rule1 = "If temperature_error is positive_large OR error_rate is positive, then pump_speed_percentage is very_high";
	rule2 = "If temperature_error is positive_small AND error_rate is zero, then pump_speed_percentage is high";
	rule3 = "If temperature_error is zero AND error_rate is zero, then pump_speed_percentage is medium";
	rule4 = "If temperature_error is negative_small AND error_rate is not positive, then pump_speed_percentage is low";
	rule5 = "If temperature_error is negative_large, then pump_speed_percentage is very_low";
	rule6 = "If error_rate is negative AND temperature_error is not negative_large, then pump_speed_percentage is high";
    
	% Add rules to FIS
	fis = addRule(fis, [rule1; rule2; rule3; rule4; rule5; rule6]);
end

% Function to train ANN Controller
function ann = trainANNController(params)
	% Generate training data
	n_samples = 1000;
    
	% Input ranges
	temp_range = [params.engine.ambient_temp, params.engine.max_temp];
	load_range = [0.5, 2.0];
	ambient_temp_range = [params.engine.ambient_temp - 10, params.engine.ambient_temp + 20];
    
	% Generate random inputs within ranges
	engine_temps = temp_range(1) + (temp_range(2) - temp_range(1)) * rand(n_samples, 1);
	engine_loads = load_range(1) + (load_range(2) - load_range(1)) * rand(n_samples, 1);
	ambient_temps = ambient_temp_range(1) + (ambient_temp_range(2) - ambient_temp_range(1)) * rand(n_samples, 1);
    
	% Create input matrix
	inputs = [engine_temps, engine_loads, ambient_temps];
    
	% Calculate ideal pump speeds for each input combination
	% This is a simplified model for training - in a real system, you'd use actual data
	outputs = zeros(n_samples, 1);
	for i = 1:n_samples
    	% Higher engine temperature -> higher pump speed
    	temp_factor = (engine_temps(i) - params.engine.optimal_temp) / 20;
   	 
    	% Higher load -> higher pump speed
    	load_factor = engine_loads(i) - 1;
   	 
    	% Higher ambient temperature -> higher pump speed
    	ambient_factor = (ambient_temps(i) - params.engine.ambient_temp) / 30;
   	 
    	% Combined factors with some nonlinearity (simplified model)
    	ideal_speed = 0.5 + 0.5 * (temp_factor + load_factor + ambient_factor);
   	 
    	% Constrain to [0, 1] range
    	outputs(i) = min(max(ideal_speed, 0), 1);
	end
    
	% Store min/max for normalization during inference
	ann.input_min = min(inputs)';
	ann.input_max = max(inputs)';
    
	% Normalize inputs for training
	inputs_normalized = (inputs - repmat(ann.input_min', n_samples, 1)) ./ ...
                    	repmat(ann.input_max' - ann.input_min', n_samples, 1);
    
	% Create and configure neural network
	net = feedforwardnet([10 5]); % 10 neurons in first hidden layer, 5 in second
	net.trainFcn = 'trainlm'; 	% Levenberg-Marquardt backpropagation
	net.trainParam.epochs = 1000;
	net.trainParam.goal = 1e-5;
	net.trainParam.min_grad = 1e-7;
    
	% Train the neural network
	[net, tr] = train(net, inputs_normalized', outputs');
    
	% Store network in output structure
	ann.net = net;
	ann.training_record = tr;
end

% Function to evaluate controller performance
function metrics = evaluateControllerPerformance(time, T_pid, T_fuzzy, T_ann, P_pid, P_fuzzy, P_ann, T_opt)
	% Calculate performance metrics
    
	% 1. Settling time (time to reach and stay within 2% of optimal temperature)
	tolerance = 0.02 * T_opt;
    
	% PID settling time
	settled_idx_pid = find(abs(T_pid - T_opt) <= tolerance & time > 50, 1, 'first');
	if isempty(settled_idx_pid)
    	metrics.settling_time_pid = Inf;
	else
    	metrics.settling_time_pid = time(settled_idx_pid);
	end
    
	% Fuzzy settling time
	settled_idx_fuzzy = find(abs(T_fuzzy - T_opt) <= tolerance & time > 50, 1, 'first');
	if isempty(settled_idx_fuzzy)
    	metrics.settling_time_fuzzy = Inf;
	else
    	metrics.settling_time_fuzzy = time(settled_idx_fuzzy);
	end
    
	% ANN settling time
	settled_idx_ann = find(abs(T_ann - T_opt) <= tolerance & time > 50, 1, 'first');
	if isempty(settled_idx_ann)
    	metrics.settling_time_ann = Inf;
	else
    	metrics.settling_time_ann = time(settled_idx_ann);
	end
    
	% 2. Overshoot
	metrics.overshoot_pid = max(0, max(T_pid) - T_opt);
	metrics.overshoot_fuzzy = max(0, max(T_fuzzy) - T_opt);
	metrics.overshoot_ann = max(0, max(T_ann) - T_opt);
    
	% 3. Steady-state error (average error in last 100 seconds)
	steady_state_range = max(1, length(time) - round(100/mean(diff(time)))):length(time);
	metrics.steady_state_error_pid = mean(abs(T_pid(steady_state_range) - T_opt));
	metrics.steady_state_error_fuzzy = mean(abs(T_fuzzy(steady_state_range) - T_opt));
	metrics.steady_state_error_ann = mean(abs(T_ann(steady_state_range) - T_opt));
    
	% 4. Energy consumption (average power consumption)
	metrics.avg_power_pid = mean(P_pid);
	metrics.avg_power_fuzzy = mean(P_fuzzy);
	metrics.avg_power_ann = mean(P_ann);
    
	% 5. Temperature stability (standard deviation in steady state)
	metrics.temp_stability_pid = std(T_pid(steady_state_range));
	metrics.temp_stability_fuzzy = std(T_fuzzy(steady_state_range));
	metrics.temp_stability_ann = std(T_ann(steady_state_range));
    
	% 6. Calculate integrated absolute error (IAE)
	metrics.iae_pid = sum(abs(T_pid - T_opt)) * mean(diff(time));
	metrics.iae_fuzzy = sum(abs(T_fuzzy - T_opt)) * mean(diff(time));
	metrics.iae_ann = sum(abs(T_ann - T_opt)) * mean(diff(time));
    
	% 7. Control effort (variance of control signal)
	metrics.control_effort_pid = var(P_pid);
	metrics.control_effort_fuzzy = var(P_fuzzy);
	metrics.control_effort_ann = var(P_ann);
end

% Function to plot simulation results and comparisons
function plotResults(time, T_pid, T_fuzzy, T_ann, C_pid, C_fuzzy, C_ann, ...
                	P_pid, P_fuzzy, P_ann, load_profile, ambient_temp, params, metrics)
	% Create a figure for engine temperature comparison
	figure('Name', 'Engine Temperature Comparison', 'Position', [100, 100, 900, 600]);
    
	% Plot engine temperatures
	subplot(3, 1, 1);
	plot(time, T_pid, 'b-', 'LineWidth', 1.5);
	hold on;
	plot(time, T_fuzzy, 'r-', 'LineWidth', 1.5);
	plot(time, T_ann, 'g-', 'LineWidth', 1.5);
	plot(time, params.engine.optimal_temp * ones(size(time)), 'k--');
	xlabel('Time (s)');
	ylabel('Engine Temperature (°C)');
	legend('PID', 'Fuzzy Logic', 'ANN', 'Optimal Temp');
	title('Engine Temperature Response');
	grid on;
    
	% Plot control signals (pump speeds)
	subplot(3, 1, 2);
	plot(time, C_pid, 'b-', 'LineWidth', 1.5);
	hold on;
	plot(time, C_fuzzy, 'r-', 'LineWidth', 1.5);
	plot(time, C_ann, 'g-', 'LineWidth', 1.5);
	xlabel('Time (s)');
	ylabel('Pump Speed (RPM)');
	legend('PID', 'Fuzzy Logic', 'ANN');
	title('Control Signal (Pump Speed)');
	grid on;
    
	% Plot power consumption
	subplot(3, 1, 3);
	plot(time, P_pid, 'b-', 'LineWidth', 1.5);
	hold on;
	plot(time, P_fuzzy, 'r-', 'LineWidth', 1.5);
	plot(time, P_ann, 'g-', 'LineWidth', 1.5);
	xlabel('Time (s)');
	ylabel('Power Consumption (kW)');
	legend('PID', 'Fuzzy Logic', 'ANN');
	title('Power Consumption');
	grid on;
    
	% Create a figure for disturbances
	figure('Name', 'System Disturbances', 'Position', [1000, 100, 900, 400]);
    
	% Plot load profile
	subplot(2, 1, 1);
	plot(time, load_profile, 'k-', 'LineWidth', 1.5);
	xlabel('Time (s)');
	ylabel('Engine Load (relative)');
	title('Engine Load Profile');
	grid on;
    
	% Plot ambient temperature
	subplot(2, 1, 2);
	plot(time, ambient_temp, 'k-', 'LineWidth', 1.5);
	xlabel('Time (s)');
	ylabel('Ambient Temperature (°C)');
	title('Ambient Temperature Profile');
	grid on;
    
	% Create a figure for performance metrics comparison
	figure('Name', 'Performance Metrics Comparison', 'Position', [100, 700, 900, 500]);
    
	% Performance metrics to plot
	metric_names = {'Settling Time (s)', 'Overshoot (°C)', 'Steady-State Error (°C)', ...
               	'Avg. Power (kW)', 'Temp. Stability (°C)', 'IAE'};
    
	% Extract values for each metric for each controller
	metric_values = [
    	metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann;
    	metrics.overshoot_pid, metrics.overshoot_fuzzy, metrics.overshoot_ann;
    	metrics.steady_state_error_pid, metrics.steady_state_error_fuzzy, metrics.steady_state_error_ann;
    	metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann;
    	metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann;
    	metrics.iae_pid/1000, metrics.iae_fuzzy/1000, metrics.iae_ann/1000 % Scaled IAE for better visualization
	];
    
	% Create bar chart
	bar(metric_values');
	set(gca, 'XTickLabel', {'PID', 'Fuzzy Logic', 'ANN'});
	legend(metric_names);
	title('Performance Metrics Comparison');
	ylabel('Metric Value');
	grid on;
    
	% Display normalized radar chart for comprehensive comparison
	figure('Name', 'Controller Performance Radar Chart', 'Position', [1000, 700, 600, 500]);
    
	% Normalize metrics for radar chart (lower is better for all metrics)
	metrics_for_radar = [
    	metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann;
    	metrics.overshoot_pid, metrics.overshoot_fuzzy, metrics.overshoot_ann;
    	metrics.steady_state_error_pid, metrics.steady_state_error_fuzzy, metrics.steady_state_error_ann;
    	metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann;
    	metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann;
    	metrics.control_effort_pid, metrics.control_effort_fuzzy, metrics.control_effort_ann
	];
    
	% Normalize each row (metric) to [0,1] where 0 is best
	norm_metrics = zeros(size(metrics_for_radar));
	for i = 1:size(metrics_for_radar, 1)
    	row_max = max(metrics_for_radar(i,:));
    	row_min = min(metrics_for_radar(i,:));
    	if row_max > row_min
        	norm_metrics(i,:) = (metrics_for_radar(i,:) - row_min) / (row_max - row_min);
    	else
        	norm_metrics(i,:) = zeros(1, size(metrics_for_radar, 2));
    	end
	end
    
	% Invert values so that 1 is best (for radar chart visualization)
	norm_metrics = 1 - norm_metrics;
    
	% Plot radar chart
	radar_labels = {'Settling Time', 'Overshoot', 'Steady-State Error', ...
               	'Energy Efficiency', 'Temperature Stability', 'Control Effort'};
	radar_plot = radarChart(norm_metrics', radar_labels);
	title('Controller Performance Comparison (Higher is Better)');
	legend('PID', 'Fuzzy Logic', 'ANN', 'Location', 'SouthEast');
end

% Function to create a radar chart
function h = radarChart(data, labels)
	% Number of metrics/axes
	n = size(data, 2);
    
	% Calculate angles for each axis
	theta = linspace(0, 2*pi, n+1)';
	theta(end) = theta(1); % Close the circle
    
	% Create a figure
	h = figure;
    
	% Colors for each controller
	colors = {'b', 'r', 'g'};
    
	% Plot data for each controller
	hold on;
	for i = 1:size(data, 1)
    	% Add the first point at the end to close the polygon
    	values = [data(i,:), data(i,1)];
   	 
    	% Convert to Cartesian coordinates and plot
    	x = values .* cos(theta);
    	y = values .* sin(theta);
    	plot(x, y, [colors{i}, '-o'], 'LineWidth', 2);
   	 
    	% Fill polygon
    	fill(x, y, colors{i}, 'FaceAlpha', 0.1);
	end
    
	% Plot reference circles
	for r = 0.25:0.25:1
    	x_circle = r * cos(linspace(0, 2*pi, 100));
    	y_circle = r * sin(linspace(0, 2*pi, 100));
    	plot(x_circle, y_circle, 'k--', 'LineWidth', 0.5);
	end
    
	% Plot axes
	for i = 1:n
    	plot([0, cos(theta(i))], [0, sin(theta(i))], 'k-', 'LineWidth', 0.5);
   	 
    	% Add labels with some offset
    	text_offset = 1.1; % Place labels slightly outside the unit circle
    	text(text_offset * cos(theta(i)), text_offset * sin(theta(i)), labels{i}, ...
         	'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
	end
    
	% Set axis limits and appearance
	axis square tight;
	axis off;
end     
