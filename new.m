%% Electric Automotive Cooling System Simulation with ANN, PID, and FLC Controllers
% This script simulates and compares the performance of three control approaches
% (PID, Fuzzy Logic, and ANN) for regulating the cooling system of an electric vehicle.
% The simulation includes models for water pump dynamics, heat transfer mechanisms,
% and engine temperature regulation.


close all;
clc;

%% System Parameters
% Engine and cooling system parameters
params.engine.mass = 150;                  % Engine mass (kg)
params.engine.specific_heat = 450;         % Specific heat capacity of engine material (J/kg·K)
params.engine.heat_generation_nom = 30000; % Nominal heat generation rate (W)
params.engine.optimal_temp = 90;           % Optimal engine temperature (°C)
params.engine.max_temp = 110;              % Maximum allowable engine temperature (°C)
params.engine.ambient_temp = 25;           % Ambient temperature (°C)

% Water pump parameters
params.pump.max_flow_rate = 2.5;           % Maximum flow rate (kg/s)
params.pump.min_flow_rate = 0.2;           % Minimum flow rate (kg/s)
params.pump.max_speed = 3000;              % Maximum pump speed (RPM)
params.pump.time_constant = 0.5;           % Pump response time constant (s)

% Radiator parameters
params.radiator.efficiency = 0.85;         % Radiator heat transfer efficiency
params.radiator.heat_transfer_coeff = 800; % Heat transfer coefficient (W/K)

% Coolant parameters
params.coolant.density = 1000;             % Coolant density (kg/m³)
params.coolant.specific_heat = 4186;       % Specific heat capacity of coolant (J/kg·K)
params.coolant.volume = 5;                 % Coolant volume in system (L)

% Simulation parameters
sim_time = 600;                            % Simulation time (s)
sample_time = 0.1;                         % Sample time (s)
time = 0:sample_time:sim_time;             % Time vector
n_samples = length(time);

% Disturbances (to test controller robustness)
% 1. Variable engine load (simulates acceleration/deceleration)
load_profile = ones(1, n_samples);
load_profile(1000:2000) = 1.5;             % Higher load (150%)
load_profile(3000:4000) = 0.7;             % Lower load (70%)
load_profile(5000:5500) = 1.8;             % Very high load (180%)

% 2. Variable ambient temperature
ambient_temp_profile = params.engine.ambient_temp * ones(1, n_samples);
ambient_temp_profile(2000:3500) = params.engine.ambient_temp + 15; % Hot day scenario
ambient_temp_profile(4500:5500) = params.engine.ambient_temp - 10; % Cold day scenario

%% Initialize State Variables
% Engine temperature (°C)
T_engine = params.engine.ambient_temp * ones(1, n_samples);
% Coolant temperature (°C)
T_coolant = params.engine.ambient_temp * ones(1, n_samples);
% Pump flow rate (kg/s)
flow_rate = params.pump.min_flow_rate * ones(1, n_samples);
% Pump speed command (RPM)
pump_speed_command = zeros(1, n_samples);
% Heat generated by engine (W)
heat_generated = zeros(1, n_samples);
% Heat dissipated by radiator (W)
heat_dissipated = zeros(1, n_samples);

%% Controller Setup

% 1. PID Controller
pid.Kp = 150;                              % Proportional gain
pid.Ki = 15;                               % Integral gain
pid.Kd = 10;                               % Derivative gain
pid.error_sum = 0;                         % Initialize error sum for integral term
pid.last_error = 0;                        % Initialize last error for derivative term

% 2. Fuzzy Logic Controller Setup
fis = setupFuzzyController();              % Function to set up fuzzy controller (defined below)

% 3. ANN Controller
% Train ANN controller with sample data
ann = trainANNController(params);          % Function to train ANN (defined below)

% Control signal outputs for each controller type
control_pid = zeros(1, n_samples);
control_fuzzy = zeros(1, n_samples);
control_ann = zeros(1, n_samples);

% Engine temperature results for each controller
T_engine_pid = params.engine.ambient_temp * ones(1, n_samples);
T_engine_fuzzy = params.engine.ambient_temp * ones(1, n_samples);
T_engine_ann = params.engine.ambient_temp * ones(1, n_samples);

% Power consumption for each controller
power_consumption_pid = zeros(1, n_samples);
power_consumption_fuzzy = zeros(1, n_samples);
power_consumption_ann = zeros(1, n_samples);

%% Run Simulations for Each Controller Type
controllers = {'PID', 'Fuzzy', 'ANN'};

for controller_idx = 1:length(controllers)
    controller_type = controllers{controller_idx};
    
    % Reset initial conditions
  
    



    % In your simulation loop:
    T_engine_current = min(max(T_engine_current, params.engine.ambient_temp), params.engine.max_temp);
    T_coolant_current = min(max(T_coolant_current, params.engine.ambient_temp), params.engine.max_temp);
    flow_rate_current = params.pump.min_flow_rate;
    pid.error_sum = 0;
    pid.last_error = 0;
    
    % Simulation loop
    for i = 2:n_samples
        % Calculate heat generated by engine (affected by load profile)
        heat_gen = params.engine.heat_generation_nom * load_profile(i-1);
        heat_generated(i) = heat_gen;
        
        % Calculate heat dissipated by radiator
        heat_diss = params.radiator.heat_transfer_coeff * (T_coolant_current - ambient_temp_profile(i-1)) * flow_rate_current * params.radiator.efficiency;
        heat_dissipated(i) = max(0, heat_diss); % Cannot be negative
        
        % Calculate engine temperature change
        dT_engine = (heat_gen - heat_diss * params.radiator.efficiency) * sample_time /    (params.engine.mass * params.engine.specific_heat);
        T_engine_current = T_engine_current + dT_engine;
        
        % Apply appropriate controller based on selected type
        if strcmp(controller_type, 'PID')
            % PID control
            error = params.engine.optimal_temp - T_engine_current;
            pid.error_sum = pid.error_sum + error * sample_time;
            error_rate = (error - pid.last_error) / sample_time;
            pid.last_error = error;
            
            % PID output calculation
            control_output = pid.Kp * error + pid.Ki * pid.error_sum + pid.Kd * error_rate;
            
            % Constrain control output to pump operating range
            pump_speed = min(max(0, control_output), params.pump.max_speed);
            control_pid(i) = pump_speed;
            
        elseif strcmp(controller_type, 'Fuzzy')
            % Fuzzy Logic control
            error = params.engine.optimal_temp - T_engine_current;
            error_rate = (error - (params.engine.optimal_temp - T_engine(i-1))) / sample_time;
            
            % Evaluate fuzzy rules
            output = evalfis(fis, [error, error_rate]);
            
            % Scale output to pump speed range
            pump_speed = output * params.pump.max_speed;
            control_fuzzy(i) = pump_speed;
            
        elseif strcmp(controller_type, 'ANN')
            % ANN control
            % Prepare inputs for ANN
            input_data = [T_engine_current; 
                          load_profile(i-1); 
                          ambient_temp_profile(i-1)];
            
            % Normalize inputs based on training data ranges
            normalized_input = (input_data - ann.input_min) ./ (ann.input_max - ann.input_min);
            
            % Get ANN output 
            % todo:  i am replacing this
            % ann_output = sim(ann.net, normalized_input');
            ann_output = ann.net(normalized_input);  % Column vector input
            
            % Denormalize output to get pump speed
            pump_speed = ann_output * (params.pump.max_speed - 0) + 0;
            control_ann(i) = pump_speed;
        end
        
        % Apply control action (with pump dynamics)
        if strcmp(controller_type, 'PID')
            flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
        elseif strcmp(controller_type, 'Fuzzy')
            flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
        elseif strcmp(controller_type, 'ANN')
            flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
        end
        
        % Apply first-order pump dynamics
        flow_rate_current = flow_rate_current + (flow_rate_target - flow_rate_current) *    (1 - exp(-sample_time / params.pump.time_constant));
        
        % Calculate power consumption (proportional to cube of speed)
        if strcmp(controller_type, 'PID')
            power_consumption_pid(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
        elseif strcmp(controller_type, 'Fuzzy')
            power_consumption_fuzzy(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
        elseif strcmp(controller_type, 'ANN')
            power_consumption_ann(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
        end
        
        % Calculate coolant temperature change
        coolant_heat_absorbed = heat_gen - heat_diss;
        dT_coolant = coolant_heat_absorbed * sample_time /  (params.coolant.density * params.coolant.volume * 0.001 * params.coolant.specific_heat);
        T_coolant_current = T_coolant_current + dT_coolant;
        
        % Store results
        if strcmp(controller_type, 'PID')
            T_engine_pid(i) = T_engine_current;
        elseif strcmp(controller_type, 'Fuzzy')
            T_engine_fuzzy(i) = T_engine_current;
        elseif strcmp(controller_type, 'ANN')
            T_engine_ann(i) = T_engine_current;
        end
    end
end

%% Performance Evaluation
% Calculate performance metrics for each controller
metrics = evaluateControllerPerformance(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
                                       power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
                                       params.engine.optimal_temp);

%% Visualize Results
plotResults(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
           control_pid, control_fuzzy, control_ann, ...
           power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
           load_profile, ambient_temp_profile, params, metrics);

%% Helper Functions

function fis = setupFuzzyController()
    % Create a new Fuzzy Inference System (FIS)
    fis = mamfis('Name', 'CoolingSystem');  % Corrected usage of mamfis
    
    % Add input variable 'temperature_error'
    fis = addInput(fis, [-30 30], 'Name', 'temperature_error');
    fis = addMF(fis, 'temperature_error', 'trimf', [-30 -20 -10], 'Name', 'negative_large');
    fis = addMF(fis, 'temperature_error', 'trimf', [-15 -5 0], 'Name', 'negative_small');
    fis = addMF(fis, 'temperature_error', 'trimf', [-5 0 5], 'Name', 'zero');
    fis = addMF(fis, 'temperature_error', 'trimf', [0 5 15], 'Name', 'positive_small');
    fis = addMF(fis, 'temperature_error', 'trimf', [10 20 30], 'Name', 'positive_large');
    
    % Add input variable 'error_rate'
    fis = addInput(fis, [-10 10], 'Name', 'error_rate');
    fis = addMF(fis, 'error_rate', 'trimf', [-10 -5 0], 'Name', 'negative');
    fis = addMF(fis, 'error_rate', 'trimf', [-3 0 3], 'Name', 'zero');
    fis = addMF(fis, 'error_rate', 'trimf', [0 5 10], 'Name', 'positive');
    
    % Add output variable 'pump_speed_percentage'
    fis = addOutput(fis, [0 1], 'Name', 'pump_speed_percentage');
    fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0 0.1 0.3], 'Name', 'very_low');
    fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.2 0.4 0.6], 'Name', 'low');
    fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.4 0.6 0.8], 'Name', 'medium');
    fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.6 0.8 0.9], 'Name', 'high');
    fis = addMF(fis, 'pump_speed_percentage', 'trimf', [0.8 1 1], 'Name', 'very_high');
    
    % Add fuzzy rules
    rule1 = "If temperature_error is positive_large OR error_rate is positive, then pump_speed_percentage is very_high";
    rule2 = "If temperature_error is positive_small AND error_rate is zero, then pump_speed_percentage is high";
    rule3 = "If temperature_error is zero AND error_rate is zero, then pump_speed_percentage is medium";
    rule4 = "If temperature_error is negative_small AND error_rate is not positive, then pump_speed_percentage is low";
    rule5 = "If temperature_error is negative_large, then pump_speed_percentage is very_low";
    rule6 = "If error_rate is negative AND temperature_error is not negative_large, then pump_speed_percentage is high";
    
    % Add rules to FIS
    fis = addRule(fis, [rule1; rule2; rule3; rule4; rule5; rule6]);
end

% % Function to train ANN Controller
% function ann = trainANNController(params)
%     % Generate training data
%     n_samples = 1000;
    
%     % Input ranges
%     temp_range = [params.engine.ambient_temp, params.engine.max_temp];
%     load_range = [0.5, 2.0];
%     ambient_temp_range = [params.engine.ambient_temp - 10, params.engine.ambient_temp + 20];
    
%     % Generate random inputs within ranges
%     engine_temps = temp_range(1) + (temp_range(2) - temp_range(1)) * rand(n_samples, 1);
%     engine_loads = load_range(1) + (load_range(2) - load_range(1)) * rand(n_samples, 1);
%     ambient_temps = ambient_temp_range(1) + (ambient_temp_range(2) - ambient_temp_range(1)) * rand(n_samples, 1);
    
%     % Create input matrix
%     inputs = [engine_temps, engine_loads, ambient_temps];
    
%     % Calculate ideal pump speeds for each input combination
%     % This is a simplified model for training - in a real system, you'd use actual data
%     outputs = zeros(n_samples, 1);
%     for i = 1:n_samples
%         % Higher engine temperature -> higher pump speed
%         temp_factor = (engine_temps(i) - params.engine.optimal_temp) / 20;
        
%         % Higher load -> higher pump speed
%         load_factor = engine_loads(i) - 1;
        
%         % Higher ambient temperature -> higher pump speed
%         ambient_factor = (ambient_temps(i) - params.engine.ambient_temp) / 30;
        
%         % Combined factors with some nonlinearity (simplified model)
%         ideal_speed = 0.5 + 0.5 * (temp_factor + load_factor + ambient_factor);
        
%         % Constrain to [0, 1] range
%         outputs(i) = min(max(ideal_speed, 0), 1);
%     end
    
%     % Store min/max for normalization during inference
%     ann.input_min = min(inputs)';
%     ann.input_max = max(inputs)';
    
%     % Normalize inputs for training
%     inputs_normalized = (inputs - repmat(ann.input_min', n_samples, 1)) ./ ...
%                         repmat(ann.input_max' - ann.input_min', n_samples, 1);
    
%     % Create and configure neural network
%     net = feedforwardnet([10 5]); % 10 neurons in first hidden layer, 5 in second
%     net.trainFcn = 'trainlm';     % Levenberg-Marquardt backpropagation
%     % In the trainANNController function, modify the network training parameters:
%     net.trainParam.epochs = 1000;     % Maximum epochs
%     net.trainParam.goal = 1e-5;       % Performance goal
%     net.trainParam.min_grad = 1e-7;   % Minimum gradient
%     net.trainParam.max_fail = 20;     % Maximum validation failures
%     net.trainParam.show = 25;         % Show progress every 25 epochs
%     net.trainParam.time = Inf;        % No time limit

    
%     % Train the neural network
%     [net, tr] = train(net, inputs_normalized', outputs');
    
%     % Store network in output structure
%     ann.net = net;
%     ann.training_record = tr;
% end



function ann = trainANNController(params)
    % Generate comprehensive training data
    n_samples = 10000;
    
    % Input ranges with wider coverage
    temp_range = [params.engine.ambient_temp-15, params.engine.max_temp+5];
    load_range = [0.3, 2.2];
    ambient_temp_range = [params.engine.ambient_temp-15, params.engine.ambient_temp+25];
    
    % Generate varied training data
    engine_temps = [linspace(temp_range(1), temp_range(2), 1000), ...
                   params.engine.optimal_temp * ones(1, 3000), ...
                   temp_range(1) + (temp_range(2)-temp_range(1)) * rand(1, n_samples-4000)];
    
    engine_loads = [linspace(load_range(1), load_range(2), 1000), ...
                   1.0 * ones(1, 3000), ...
                   load_range(1) + (load_range(2)-load_range(1)) * rand(1, n_samples-4000)];
    
    ambient_temps = [linspace(ambient_temp_range(1), ambient_temp_range(2), 1000), ...
                    params.engine.ambient_temp * ones(1, 3000), ...
                    ambient_temp_range(1) + (ambient_temp_range(2)-ambient_temp_range(1)) * rand(1, n_samples-4000)];
    
    % Create properly formatted input matrix (3 features × n_samples)
    inputs = [engine_temps; engine_loads; ambient_temps]; % 3×N
    
    % Calculate target outputs (1×N)
    outputs = 0.5 + 0.5 * tanh(...
        (engine_temps - params.engine.optimal_temp)/20 + ...
        (engine_loads - 1) + ...
        (ambient_temps - params.engine.ambient_temp)/30);
    outputs = max(min(outputs, 1), 0); % Clip to [0,1] range
    
    % Create and configure neural network
    net = feedforwardnet([15 10], 'trainlm'); % 2 hidden layers
    
    % Configure network properties
    net.inputs{1}.size = 3; % Explicitly set 3 input features
    net.trainParam.epochs = 1000;
    net.trainParam.goal = 1e-5;
    % net.trainParam.min_grad = 1e-6;
    net.trainParam.max_fail = 50;  % Increased from default 6
    net.trainParam.min_grad = 1e-10; % More lenient than default 1e-5
    net.trainParam.mu_max = 1e20;  % Allow larger learning rates
    net.divideParam.trainRatio = 0.7;
    net.divideParam.valRatio = 0.15;
    net.divideParam.testRatio = 0.15;
    
    % Train the network
    [net, ~] = train(net, inputs, outputs);
    
    % Store network and normalization parameters
    ann.net = net;
    ann.input_min = min(inputs, [], 2); % Column vector of minima
    ann.input_max = max(inputs, [], 2); % Column vector of maxima
    
    % Verify network architecture
    disp(['Trained ANN with ' num2str(net.inputs{1}.size) ' inputs']);
    disp(['and ' num2str(net.layers{end}.size) ' outputs']);
    view(net);
end

% Function to evaluate controller performance
function metrics = evaluateControllerPerformance(time, T_pid, T_fuzzy, T_ann, P_pid, P_fuzzy, P_ann, T_opt)
    % Calculate performance metrics
    
    % 1. Settling time (time to reach and stay within 2% of optimal temperature)
    tolerance = 0.02 * T_opt;
    
    % PID settling time
    settled_idx_pid = find(abs(T_pid - T_opt) <= tolerance & time > 50, 1, 'first');
    if isempty(settled_idx_pid)
        metrics.settling_time_pid = Inf;
    else
        metrics.settling_time_pid = time(settled_idx_pid);
    end
    
    % Fuzzy settling time
    settled_idx_fuzzy = find(abs(T_fuzzy - T_opt) <= tolerance & time > 50, 1, 'first');
    if isempty(settled_idx_fuzzy)
        metrics.settling_time_fuzzy = Inf;
    else
        metrics.settling_time_fuzzy = time(settled_idx_fuzzy);
    end
    
    % ANN settling time
    settled_idx_ann = find(abs(T_ann - T_opt) <= tolerance & time > 50, 1, 'first');
    if isempty(settled_idx_ann)
        metrics.settling_time_ann = Inf;
    else
        metrics.settling_time_ann = time(settled_idx_ann);
    end
    
    % 2. Overshoot
    metrics.overshoot_pid = max(0, max(T_pid) - T_opt);
    metrics.overshoot_fuzzy = max(0, max(T_fuzzy) - T_opt);
    metrics.overshoot_ann = max(0, max(T_ann) - T_opt);
    
    % 3. Steady-state error (average error in last 100 seconds)
    steady_state_range = max(1, length(time) - round(100/mean(diff(time)))):length(time);
    metrics.steady_state_error_pid = mean(abs(T_pid(steady_state_range) - T_opt));
    metrics.steady_state_error_fuzzy = mean(abs(T_fuzzy(steady_state_range) - T_opt));
    metrics.steady_state_error_ann = mean(abs(T_ann(steady_state_range) - T_opt));
    
    % 4. Energy consumption (average power consumption)
    metrics.avg_power_pid = mean(P_pid);
    metrics.avg_power_fuzzy = mean(P_fuzzy);
    metrics.avg_power_ann = mean(P_ann);
    
    % 5. Temperature stability (standard deviation in steady state)
    metrics.temp_stability_pid = std(T_pid(steady_state_range));
    metrics.temp_stability_fuzzy = std(T_fuzzy(steady_state_range));
    metrics.temp_stability_ann = std(T_ann(steady_state_range));
    
    % 6. Calculate integrated absolute error (IAE)
    metrics.iae_pid = sum(abs(T_pid - T_opt)) * mean(diff(time));
    metrics.iae_fuzzy = sum(abs(T_fuzzy - T_opt)) * mean(diff(time));
    metrics.iae_ann = sum(abs(T_ann - T_opt)) * mean(diff(time));
    
    % 7. Control effort (variance of control signal)
    metrics.control_effort_pid = var(P_pid);
    metrics.control_effort_fuzzy = var(P_fuzzy);
    metrics.control_effort_ann = var(P_ann);
end

% Function to plot simulation results and comparisons
function plotResults(time, T_pid, T_fuzzy, T_ann, C_pid, C_fuzzy, C_ann, ...
                    P_pid, P_fuzzy, P_ann, load_profile, ambient_temp, params, metrics)
    % Create a figure for engine temperature comparison
    figure('Name', 'Engine Temperature Comparison', 'Position', [100, 100, 900, 600]);
    
    % Plot engine temperatures
    subplot(3, 1, 1);
    plot(time, T_pid, 'b-', 'LineWidth', 1.5);
    hold on;
    plot(time, T_fuzzy, 'r-', 'LineWidth', 1.5);
    plot(time, T_ann, 'g-', 'LineWidth', 1.5);
    plot(time, params.engine.optimal_temp * ones(size(time)), 'k--');
    xlabel('Time (s)');
    ylabel('Engine Temperature (°C)');
    legend('PID', 'Fuzzy Logic', 'ANN', 'Optimal Temp');
    title('Engine Temperature Response');
    grid on;
    
    % Plot control signals (pump speeds)
    subplot(3, 1, 2);
    plot(time, C_pid, 'b-', 'LineWidth', 1.5);
    hold on;
    plot(time, C_fuzzy, 'r-', 'LineWidth', 1.5);
    plot(time, C_ann, 'g-', 'LineWidth', 1.5);
    xlabel('Time (s)');
    ylabel('Pump Speed (RPM)');
    legend('PID', 'Fuzzy Logic', 'ANN');
    title('Control Signal (Pump Speed)');
    grid on;
    
    % Plot power consumption
    subplot(3, 1, 3);
    plot(time, P_pid, 'b-', 'LineWidth', 1.5);
    hold on;
    plot(time, P_fuzzy, 'r-', 'LineWidth', 1.5);
    plot(time, P_ann, 'g-', 'LineWidth', 1.5);
    xlabel('Time (s)');
    ylabel('Power Consumption (kW)');
    legend('PID', 'Fuzzy Logic', 'ANN');
    title('Power Consumption');
    grid on;
    
    % Create a figure for disturbances
    figure('Name', 'System Disturbances', 'Position', [1000, 100, 900, 400]);
    
    % Plot load profile
    subplot(2, 1, 1);
    plot(time, load_profile, 'k-', 'LineWidth', 1.5);
    xlabel('Time (s)');
    ylabel('Engine Load (relative)');
    title('Engine Load Profile');
    grid on;
    
    % Plot ambient temperature
    subplot(2, 1, 2);
    plot(time, ambient_temp, 'k-', 'LineWidth', 1.5);
    xlabel('Time (s)');
    ylabel('Ambient Temperature (°C)');
    title('Ambient Temperature Profile');
    grid on;
    
    % Create a figure for performance metrics comparison
    figure('Name', 'Performance Metrics Comparison', 'Position', [100, 700, 900, 500]);
    
    % Performance metrics to plot
    metric_names = {'Settling Time (s)', 'Overshoot (°C)', 'Steady-State Error (°C)', ...
                   'Avg. Power (kW)', 'Temp. Stability (°C)', 'IAE'};
    
    % Extract values for each metric for each controller
    metric_values = [
        metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann;
        metrics.overshoot_pid, metrics.overshoot_fuzzy, metrics.overshoot_ann;
        metrics.steady_state_error_pid, metrics.steady_state_error_fuzzy, metrics.steady_state_error_ann;
        metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann;
        metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann;
        metrics.iae_pid/1000, metrics.iae_fuzzy/1000, metrics.iae_ann/1000 % Scaled IAE for better visualization
    ];
    
    % Create bar chart
    bar(metric_values');
    set(gca, 'XTickLabel', {'PID', 'Fuzzy Logic', 'ANN'});
    legend(metric_names);
    title('Performance Metrics Comparison');
    ylabel('Metric Value');
    grid on;
    
    % Display normalized radar chart for comprehensive comparison
    figure('Name', 'Controller Performance Radar Chart', 'Position', [1000, 700, 600, 500]);
    
    % Normalize metrics for radar chart (lower is better for all metrics)
    metrics_for_radar = [
        metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann;
        metrics.overshoot_pid, metrics.overshoot_fuzzy, metrics.overshoot_ann;
        metrics.steady_state_error_pid, metrics.steady_state_error_fuzzy, metrics.steady_state_error_ann;
        metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann;
        metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann;
        metrics.control_effort_pid, metrics.control_effort_fuzzy, metrics.control_effort_ann
    ];
    
    % Normalize each row (metric) to [0,1] where 0 is best
    norm_metrics = zeros(size(metrics_for_radar));
    for i = 1:size(metrics_for_radar, 1)
        row_max = max(metrics_for_radar(i,:));
        row_min = min(metrics_for_radar(i,:));
        if row_max > row_min
            norm_metrics(i,:) = (metrics_for_radar(i,:) - row_min) / (row_max - row_min);
        else
            norm_metrics(i,:) = zeros(1, size(metrics_for_radar, 2));
        end
    end
    
    % Invert values so that 1 is best (for radar chart visualization)
    norm_metrics = 1 - norm_metrics;
    
    % Plot radar chart
    radar_labels = {'Settling Time', 'Overshoot', 'Steady-State Error', ...
                   'Energy Efficiency', 'Temperature Stability', 'Control Effort'};
    radar_plot = radarChart(norm_metrics', radar_labels);
    title('Controller Performance Comparison (Higher is Better)');
    legend('PID', 'Fuzzy Logic', 'ANN', 'Location', 'SouthEast');
end

% Function to create a radar chart
function h = radarChart(data, labels)
    % Number of metrics/axes
    n = size(data, 2);
    
    % Calculate angles for each axis
    theta = linspace(0, 2*pi, n+1)';
    theta(end) = theta(1); % Close the circle
    
    % Create a figure
    h = figure;
    
    % Colors for each controller
    colors = {'b', 'r', 'g'};
    
    % Plot data for each controller
    hold on;
    for i = 1:size(data, 1)
        % Add the first point at the end to close the polygon
        values = [data(i,:), data(i,1)];
        
        % Convert to Cartesian coordinates and plot
        x = values .* cos(theta);
        y = values .* sin(theta);
        plot(x, y, [colors{i}, '-o'], 'LineWidth', 2);
        
        % Fill polygon
        fill(x, y, colors{i}, 'FaceAlpha', 0.1);
    end
    
    % Plot reference circles
    for r = 0.25:0.25:1
        x_circle = r * cos(linspace(0, 2*pi, 100));
        y_circle = r * sin(linspace(0, 2*pi, 100));
        plot(x_circle, y_circle, 'k--', 'LineWidth', 0.5);
    end
    
    % Plot axes
    for i = 1:n
        plot([0, cos(theta(i))], [0, sin(theta(i))], 'k-', 'LineWidth', 0.5);
        
        % Add labels with some offset
        text_offset = 1.1; % Place labels slightly outside the unit circle
        text(text_offset * cos(theta(i)), text_offset * sin(theta(i)), labels{i}, ...
             'HorizontalAlignment', 'center', 'VerticalAlignment', 'middle');
    end
    
    % Set axis limits and appearance
    axis square tight;
    axis off;
end


%% Function to calculate engine temperature change
function dT_engine = calculateEngineTemperatureChange(heat_generated, heat_dissipated, params, sample_time)
    dT_engine = (heat_generated - heat_dissipated * params.radiator.efficiency) * sample_time / ...
               (params.engine.mass * params.engine.specific_heat);
end

%% Function to calculate coolant temperature change
function dT_coolant = calculateCoolantTemperatureChange(heat_absorbed, params, sample_time)
    dT_coolant = heat_absorbed * sample_time / ...
                (params.coolant.density * params.coolant.volume * 0.001 * params.coolant.specific_heat);
end

%% Function to simulate the system with different controllers
function [T_engine, control_signal, power_consumption] = simulateController(controller_type, params, time, ...
                                                                          load_profile, ambient_temp_profile, ...
                                                                          pid, fis, ann)
    % Initialize variables
    n_samples = length(time);
    sample_time = mean(diff(time));
    
    % Initialize state variables
    T_engine = params.engine.ambient_temp * ones(1, n_samples);
    T_coolant = params.engine.ambient_temp * ones(1, n_samples);
    flow_rate = params.pump.min_flow_rate * ones(1, n_samples);
    control_signal = zeros(1, n_samples);
    power_consumption = zeros(1, n_samples);
    heat_generated = zeros(1, n_samples);
    heat_dissipated = zeros(1, n_samples);
    
    % Initialize controller variables
    pid_error_sum = 0;
    pid_last_error = 0;
    
    % Simulation loop
    for i = 2:n_samples
        % Calculate heat generated by engine (affected by load profile)
        heat_gen = params.engine.heat_generation_nom * load_profile(i-1);
        heat_generated(i) = heat_gen;
        
        % Calculate heat dissipated by radiator
        heat_diss = params.radiator.heat_transfer_coeff * (T_coolant(i-1) - ambient_temp_profile(i-1)) * ...
                   flow_rate(i-1) * params.radiator.efficiency;
        heat_dissipated(i) = max(0, heat_diss); % Cannot be negative
        
        % Apply appropriate controller
        if strcmp(controller_type, 'PID')
            % PID control
            error = params.engine.optimal_temp - T_engine(i-1);
            pid_error_sum = pid_error_sum + error * sample_time;
            error_rate = (error - pid_last_error) / sample_time;
            pid_last_error = error;
            
            % PID output calculation
            control_output = pid.Kp * error + pid.Ki * pid_error_sum + pid.Kd * error_rate;
            
            % Constrain control output to pump operating range
            pump_speed = min(max(0, control_output), params.pump.max_speed);
            control_signal(i) = pump_speed;
            
        elseif strcmp(controller_type, 'Fuzzy')
            % Fuzzy Logic control
            error = params.engine.optimal_temp - T_engine(i-1);
            error_rate = (error - (params.engine.optimal_temp - T_engine(max(1, i-2)))) / sample_time;
            
            % Scale error rate to fit fuzzy input range [-10 10]
            error_rate = max(min(error_rate, 10), -10);
            
            % Evaluate fuzzy rules
            output = evalfis(fis, [error, error_rate]);
            
            % Scale output to pump speed range
            pump_speed = output * params.pump.max_speed;
            control_signal(i) = pump_speed;
       


            
        % elseif strcmp(controller_type, 'ANN')
        %     % ANN control
        %     % Prepare inputs for ANN
        %     input_data = [T_engine(i-1); 
        %                   load_profile(i-1); 
        %                   ambient_temp_profile(i-1)];
            
        %     % Normalize inputs based on training data ranges
        %     normalized_input = (input_data - ann.input_min) ./ (ann.input_max - ann.input_min);
            
        %     % Get ANN output
        %     ann_output = sim(ann.net, normalized_input');
            
        %     % Denormalize output to get pump speed
        %     pump_speed = ann_output * params.pump.max_speed;
        %     control_signal(i) = pump_speed;

        % In your simulation loop where you use the ANN:
        elseif strcmp(controller_type, 'ANN')
            % ANN control - prepare input data correctly
            current_input = [T_engine_current;          % Engine temperature
                            load_profile(i-1);          % Current load
                            ambient_temp_profile(i-1)]; % Ambient temperature
            
            % Verify input dimensions
            if numel(current_input) ~= numel(ann.input_min)
                error('Input dimension mismatch. Expected %d features, got %d', ...
                    numel(ann.input_min), numel(current_input));
            end
            
            % Normalize inputs (make sure ann.input_min and ann.input_max are column vectors)
            normalized_input = (current_input - ann.input_min) ./ (ann.input_max - ann.input_min);
            
            % Get ANN output - ensure we're using the correct dimensions
            ann_output = ann.net(normalized_input); % Using direct network call
            
            % Scale to pump speed range
            pump_speed = ann_output * params.pump.max_speed;
            pump_speed = max(min(pump_speed, params.pump.max_speed), params.pump.min_speed);
            control_signal(i) = pump_speed;
        end
        
        % Apply control action (with pump dynamics)
        flow_rate_target = (pump_speed / params.pump.max_speed) * params.pump.max_flow_rate;
        
        % Apply first-order pump dynamics
        flow_rate(i) = flow_rate(i-1) + (flow_rate_target - flow_rate(i-1)) * ...
                      (1 - exp(-sample_time / params.pump.time_constant));
        
        % Calculate power consumption (proportional to cube of speed)
        power_consumption(i) = 0.001 * (pump_speed / params.pump.max_speed)^3 * 1000; % In kW
        
        % Calculate engine temperature change
        dT_engine = calculateEngineTemperatureChange(heat_gen, heat_diss, params, sample_time);
        T_engine(i) = T_engine(i-1) + dT_engine;
        
        % Calculate coolant temperature change
        coolant_heat_absorbed = heat_gen - heat_diss;
        dT_coolant = calculateCoolantTemperatureChange(coolant_heat_absorbed, params, sample_time);
        T_coolant(i) = T_coolant(i-1) + dT_coolant;
    end
end

%% Main simulation script (alternative approach using functions)
function runSimulation()
    % Initialize parameters, controllers, and simulation variables
    [params, time, load_profile, ambient_temp_profile] = initializeSimulation();
    
    % Set up controllers
    pid = setupPIDController();
    fis = setupFuzzyController();
    ann = trainANNController(params);
    
    % Run simulations for each controller
    [T_engine_pid, control_pid, power_consumption_pid] = simulateController('PID', params, time, ...
                                                                         load_profile, ambient_temp_profile, ...
                                                                         pid, fis, ann);
    
    [T_engine_fuzzy, control_fuzzy, power_consumption_fuzzy] = simulateController('Fuzzy', params, time, ...
                                                                                load_profile, ambient_temp_profile, ...
                                                                                pid, fis, ann);
    
    [T_engine_ann, control_ann, power_consumption_ann] = simulateController('ANN', params, time, ...
                                                                          load_profile, ambient_temp_profile, ...
                                                                          pid, fis, ann);
    
    % Calculate performance metrics
    metrics = evaluateControllerPerformance(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
                                           power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
                                           params.engine.optimal_temp);
    
    % Visualize results
    plotResults(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
               control_pid, control_fuzzy, control_ann, ...
               power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
               load_profile, ambient_temp_profile, params, metrics);
end

%% Function to initialize simulation parameters
function [params, time, load_profile, ambient_temp_profile] = initializeSimulation()
    % Engine and cooling system parameters
    params.engine.mass = 150;                  % Engine mass (kg)
    params.engine.specific_heat = 450;         % Specific heat capacity of engine material (J/kg·K)
    params.engine.heat_generation_nom = 30000; % Nominal heat generation rate (W)
    params.engine.optimal_temp = 90;           % Optimal engine temperature (°C)
    params.engine.max_temp = 110;              % Maximum allowable engine temperature (°C)
    params.engine.ambient_temp = 25;           % Ambient temperature (°C)

    % Water pump parameters
    params.pump.max_flow_rate = 2.5;           % Maximum flow rate (kg/s)
    params.pump.min_flow_rate = 0.2;           % Minimum flow rate (kg/s)
    params.pump.max_speed = 3000;              % Maximum pump speed (RPM)
    params.pump.time_constant = 0.5;           % Pump response time constant (s)

    % Radiator parameters
    params.radiator.efficiency = 0.85;         % Radiator heat transfer efficiency
    params.radiator.heat_transfer_coeff = 800; % Heat transfer coefficient (W/K)

    % Coolant parameters
    params.coolant.density = 1000;             % Coolant density (kg/m³)
    params.coolant.specific_heat = 4186;       % Specific heat capacity of coolant (J/kg·K)
    params.coolant.volume = 5;                 % Coolant volume in system (L)

    % Simulation parameters
    sim_time = 600;                            % Simulation time (s)
    sample_time = 0.1;                         % Sample time (s)
    time = 0:sample_time:sim_time;             % Time vector
    n_samples = length(time);

    % Disturbances (to test controller robustness)
    % 1. Variable engine load (simulates acceleration/deceleration)
    load_profile = ones(1, n_samples);
    load_profile(1000:2000) = 1.5;             % Higher load (150%)
    load_profile(3000:4000) = 0.7;             % Lower load (70%)
    load_profile(5000:5500) = 1.8;             % Very high load (180%)

    % 2. Variable ambient temperature
    ambient_temp_profile = params.engine.ambient_temp * ones(1, n_samples);
    ambient_temp_profile(2000:3500) = params.engine.ambient_temp + 15; % Hot day scenario
    ambient_temp_profile(4500:5500) = params.engine.ambient_temp - 10; % Cold day scenario
end

%% Function to set up PID controller
function pid = setupPIDController()
    pid.Kp = 150;                              % Proportional gain
    pid.Ki = 15;                               % Integral gain
    pid.Kd = 10;                               % Derivative gain
    pid.error_sum = 0;                         % Initialize error sum for integral term
    pid.last_error = 0;                        % Initialize last error for derivative term
end

%% Enhanced performance evaluation function
function metrics = evaluateExtendedPerformance(time, T_pid, T_fuzzy, T_ann, P_pid, P_fuzzy, P_ann, T_opt)
    % Calculate all basic metrics from the original function
    metrics = evaluateControllerPerformance(time, T_pid, T_fuzzy, T_ann, P_pid, P_fuzzy, P_ann, T_opt);
    
    % Add additional performance metrics
    
    % 8. Resilience to disturbances (maximum deviation during disturbance periods)
    % Define disturbance regions (high load and extreme temperature periods)
    disturbance_regions = [1000, 2000; 2000, 3500; 5000, 5500];
    
    max_deviation_pid = 0;
    max_deviation_fuzzy = 0;
    max_deviation_ann = 0;
    
    for i = 1:size(disturbance_regions, 1)
        region_start = disturbance_regions(i, 1);
        region_end = disturbance_regions(i, 2);
        
        if region_start > length(time) || region_end > length(time)
            continue;
        end
        
        max_dev_pid = max(abs(T_pid(region_start:region_end) - T_opt));
        max_dev_fuzzy = max(abs(T_fuzzy(region_start:region_end) - T_opt));
        max_dev_ann = max(abs(T_ann(region_start:region_end) - T_opt));
        
        max_deviation_pid = max(max_deviation_pid, max_dev_pid);
        max_deviation_fuzzy = max(max_deviation_fuzzy, max_dev_fuzzy);
        max_deviation_ann = max(max_deviation_ann, max_dev_ann);
    end
    
    metrics.disturbance_resilience_pid = max_deviation_pid;
    metrics.disturbance_resilience_fuzzy = max_deviation_fuzzy;
    metrics.disturbance_resilience_ann = max_deviation_ann;
    
    % 9. Recovery time after disturbances
    % Time to recover to within 2% of optimal temperature after disturbance ends
    recovery_times_pid = [];
    recovery_times_fuzzy = [];
    recovery_times_ann = [];
    
    tolerance = 0.02 * T_opt;
    
    for i = 1:size(disturbance_regions, 1)
        region_end = disturbance_regions(i, 2);
        
        if region_end > length(time)
            continue;
        end
        
        % Find first time after disturbance where temperature is within tolerance
        recovered_idx_pid = find(abs(T_pid(region_end:end) - T_opt) <= tolerance, 1, 'first');
        recovered_idx_fuzzy = find(abs(T_fuzzy(region_end:end) - T_opt) <= tolerance, 1, 'first');
        recovered_idx_ann = find(abs(T_ann(region_end:end) - T_opt) <= tolerance, 1, 'first');
        
        if ~isempty(recovered_idx_pid)
            recovery_times_pid = [recovery_times_pid, time(region_end + recovered_idx_pid - 1) - time(region_end)];
        end
        
        if ~isempty(recovered_idx_fuzzy)
            recovery_times_fuzzy = [recovery_times_fuzzy, time(region_end + recovered_idx_fuzzy - 1) - time(region_end)];
        end
        
        if ~isempty(recovered_idx_ann)
            recovery_times_ann = [recovery_times_ann, time(region_end + recovered_idx_ann - 1) - time(region_end)];
        end
    end
    
    metrics.avg_recovery_time_pid = mean(recovery_times_pid);
    metrics.avg_recovery_time_fuzzy = mean(recovery_times_fuzzy);
    metrics.avg_recovery_time_ann = mean(recovery_times_ann);
    
    % 10. Energy efficiency index (temperature precision per unit of energy)
    temp_precision_pid = 1 / (metrics.iae_pid + 1e-10); % Avoid division by zero
    temp_precision_fuzzy = 1 / (metrics.iae_fuzzy + 1e-10);
    temp_precision_ann = 1 / (metrics.iae_ann + 1e-10);
    
    metrics.energy_efficiency_index_pid = temp_precision_pid / (metrics.avg_power_pid + 1e-10);
    metrics.energy_efficiency_index_fuzzy = temp_precision_fuzzy / (metrics.avg_power_fuzzy + 1e-10);
    metrics.energy_efficiency_index_ann = temp_precision_ann / (metrics.avg_power_ann + 1e-10);
    
    % 11. Controller responsiveness (average rate of change of control signal)
    metrics.responsiveness_pid = mean(abs(diff(P_pid)));
    metrics.responsiveness_fuzzy = mean(abs(diff(P_fuzzy)));
    metrics.responsiveness_ann = mean(abs(diff(P_ann)));
end

%% Enhanced plotting function with additional visualizations
function plotEnhancedResults(time, T_pid, T_fuzzy, T_ann, C_pid, C_fuzzy, C_ann, ...
                           P_pid, P_fuzzy, P_ann, load_profile, ambient_temp, params, metrics)
    % First create all the original plots
    plotResults(time, T_pid, T_fuzzy, T_ann, C_pid, C_fuzzy, C_ann, ...
               P_pid, P_fuzzy, P_ann, load_profile, ambient_temp, params, metrics);
    
    % Additional plot: Error over time
    figure('Name', 'Temperature Error Over Time', 'Position', [600, 300, 900, 400]);
    error_pid = T_pid - params.engine.optimal_temp;
    error_fuzzy = T_fuzzy - params.engine.optimal_temp;
    error_ann = T_ann - params.engine.optimal_temp;
    
    plot(time, error_pid, 'b-', 'LineWidth', 1.5);
    hold on;
    plot(time, error_fuzzy, 'r-', 'LineWidth', 1.5);
    plot(time, error_ann, 'g-', 'LineWidth', 1.5);
    plot(time, zeros(size(time)), 'k--');
    xlabel('Time (s)');
    ylabel('Temperature Error (°C)');
    legend('PID', 'Fuzzy Logic', 'ANN', 'Zero Error');
    title('Temperature Error Over Time');
    grid on;
    
    % Energy consumption vs. Temperature stability trade-off
    figure('Name', 'Energy vs. Stability Trade-off', 'Position', [600, 700, 700, 500]);
    
    % Extract relevant metrics
    stability = [metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann];
    energy = [metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann];
    
    scatter(stability, energy, 200, 'filled');
    hold on;
    
    % Add controller labels
    controllers = {'PID', 'Fuzzy Logic', 'ANN'};
    for i = 1:length(controllers)
        text(stability(i)*1.05, energy(i)*1.05, controllers{i}, 'FontSize', 12);
    end
    
    xlabel('Temperature Stability (Standard Deviation, °C)');
    ylabel('Average Power Consumption (kW)');
    title('Energy Efficiency vs. Temperature Stability');
    grid on;
    
    % Lower values for both axes are better
    % Add ideal point (origin) and distance lines
    plot([0, max(stability)*1.2], [0, 0], 'k--', 'LineWidth', 0.5);
    plot([0, 0], [0, max(energy)*1.2], 'k--', 'LineWidth', 0.5);
    
    % Calculate distances to origin (ideal point)
    distances = sqrt(stability.^2 + energy.^2);
    
    % Add annotation for best controller (closest to origin)
    [~, best_idx] = min(distances);
    annotation('textbox', [0.15, 0.8, 0.3, 0.1], 'String', ...
             ['Best Performance: ', controllers{best_idx}], ...
             'FaceAlpha', 0.8, 'BackgroundColor', 'w', 'EdgeColor', 'k');
    
    % Add a combined performance metrics table as a figure
    figure('Name', 'Performance Metrics Table', 'Position', [1200, 300, 800, 600]);
    
    % Create metrics table for display
    metric_names = {'Settling Time (s)', 'Overshoot (°C)', 'Steady-State Error (°C)', ...
                   'Avg. Power (kW)', 'Temp. Stability (°C)', 'IAE', 'Control Effort'};
    
    controller_names = {'PID', 'Fuzzy Logic', 'ANN'};
    
    % Extract values for each metric for each controller
    metric_values = [
        metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann;
        metrics.overshoot_pid, metrics.overshoot_fuzzy, metrics.overshoot_ann;
        metrics.steady_state_error_pid, metrics.steady_state_error_fuzzy, metrics.steady_state_error_ann;
        metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann;
        metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann;
        metrics.iae_pid/1000, metrics.iae_fuzzy/1000, metrics.iae_ann/1000; % Scaled IAE for better visualization
        metrics.control_effort_pid, metrics.control_effort_fuzzy, metrics.control_effort_ann
    ];
    
    % Create text-based table
    axes('Position', [0.1, 0.1, 0.8, 0.8]);
    axis off;
    
    % Headers
    text(0.1, 0.95, 'Metric', 'FontWeight', 'bold');
    for i = 1:length(controller_names)
        text(0.3 + (i-1)*0.2, 0.95, controller_names{i}, 'FontWeight', 'bold');
    end
    
    % Add horizontal line
    line([0.1, 0.9], [0.93, 0.93], 'Color', 'k');
    
    % Metric rows
    for i = 1:length(metric_names)
        text(0.1, 0.9 - i*0.05, metric_names{i});
        
        for j = 1:length(controller_names)
            value_str = sprintf('%.4f', metric_values(i, j));
            text(0.3 + (j-1)*0.2, 0.9 - i*0.05, value_str);
            
            % Highlight best value in each row
            [~, best_idx] = min(metric_values(i, :));
            if j == best_idx
                text(0.3 + (j-1)*0.2, 0.9 - i*0.05, value_str, 'FontWeight', 'bold', 'Color', 'green');
            end
        end
    end
    
    % Add horizontal line
    line([0.1, 0.9], [0.9 - (length(metric_names)+1)*0.05, 0.9 - (length(metric_names)+1)*0.05], 'Color', 'k');
    
    % Add overall performance score (lower is better for all metrics)
    % Normalize and sum scores
    normalized_scores = zeros(1, 3);
    for i = 1:size(metric_values, 1)
        row = metric_values(i, :);
        row_min = min(row);
        row_max = max(row);
        
        if row_max > row_min
            normalized_row = (row - row_min) / (row_max - row_min);
        else
            normalized_row = zeros(1, 3);
        end
        
        normalized_scores = normalized_scores + normalized_row;
    end
    
    % Lower score is better
    text(0.1, 0.9 - (length(metric_names)+2)*0.05, 'Overall Score (lower is better):', 'FontWeight', 'bold');
    
    for j = 1:length(controller_names)
        score_str = sprintf('%.4f', normalized_scores(j));
        text(0.3 + (j-1)*0.2, 0.9 - (length(metric_names)+2)*0.05, score_str);
    end
    
    % Highlight best overall performance
    [~, best_overall] = min(normalized_scores);
    text(0.3 + (best_overall-1)*0.2, 0.9 - (length(metric_names)+2)*0.05, ...
        sprintf('%.4f', normalized_scores(best_overall)), 'FontWeight', 'bold', 'Color', 'green');
    
    % Add conclusion
    text(0.1, 0.9 - (length(metric_names)+4)*0.05, ...
        ['Best Overall Controller: ', controller_names{best_overall}], ...
        'FontWeight', 'bold', 'FontSize', 12);
    
    % Add recommendations based on specific strengths
    text(0.1, 0.9 - (length(metric_names)+6)*0.05, 'Recommendations:', 'FontWeight', 'bold');
    
    % Find best for energy efficiency
    [~, best_energy] = min([metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann]);
    text(0.1, 0.9 - (length(metric_names)+7)*0.05, ...
        ['Best for Energy Efficiency: ', controller_names{best_energy}]);
    
    % Find best for temperature stability
    [~, best_stability] = min([metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann]);
    text(0.1, 0.9 - (length(metric_names)+8)*0.05, ...
        ['Best for Temperature Stability: ', controller_names{best_stability}]);
    
    % Find best for response time
    [~, best_response] = min([metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann]);
    text(0.1, 0.9 - (length(metric_names)+9)*0.05, ...
        ['Best for Fast Response: ', controller_names{best_response}]);
end

%% Utility function to write results to file
function writeResultsToFile(metrics, params)
    % Open file for writing
    file_id = fopen('cooling_system_results.txt', 'w');
    
    % Write header
    fprintf(file_id, 'Electric Automotive Cooling System Simulation Results\n');
    fprintf(file_id, '=====================================================\n\n');
    
    % Write simulation parameters
    fprintf(file_id, 'Simulation Parameters:\n');
    fprintf(file_id, '----------------------\n');
    fprintf(file_id, 'Engine Mass: %.2f kg\n', params.engine.mass);
    fprintf(file_id, 'Engine Specific Heat: %.2f J/kg·K\n', params.engine.specific_heat);
    fprintf(file_id, 'Nominal Heat Generation: %.2f W\n', params.engine.heat_generation_nom);
    fprintf(file_id, 'Optimal Engine Temperature: %.2f °C\n', params.engine.optimal_temp);
    fprintf(file_id, 'Maximum Engine Temperature: %.2f °C\n', params.engine.max_temp);
    fprintf(file_id, 'Ambient Temperature: %.2f °C\n', params.engine.ambient_temp);
    fprintf(file_id, 'Maximum Pump Flow Rate: %.2f kg/s\n', params.pump.max_flow_rate);
    fprintf(file_id, 'Maximum Pump Speed: %.2f RPM\n', params.pump.max_speed);
    fprintf(file_id, 'Radiator Efficiency: %.2f\n', params.radiator.efficiency);
    fprintf(file_id, 'Coolant Volume: %.2f L\n\n', params.coolant.volume);
    
    % Write performance metrics
    fprintf(file_id, 'Performance Metrics:\n');
    fprintf(file_id, '-------------------\n');
    fprintf(file_id, 'Metric                      PID        Fuzzy Logic      ANN\n');
    fprintf(file_id, '---------------------------------------------------------------\n');
    fprintf(file_id, 'Settling Time (s)           %.2f       %.2f             %.2f\n', ...
            metrics.settling_time_pid, metrics.settling_time_fuzzy, metrics.settling_time_ann);
    fprintf(file_id, 'Overshoot (°C)              %.2f       %.2f             %.2f\n', ...
            metrics.overshoot_pid, metrics.overshoot_fuzzy, metrics.overshoot_ann);
    fprintf(file_id, 'Steady-State Error (°C)     %.4f       %.4f             %.4f\n', ...
            metrics.steady_state_error_pid, metrics.steady_state_error_fuzzy, metrics.steady_state_error_ann);
    fprintf(file_id, 'Average Power (kW)          %.4f       %.4f             %.4f\n', ...
            metrics.avg_power_pid, metrics.avg_power_fuzzy, metrics.avg_power_ann);
    fprintf(file_id, 'Temperature Stability (°C)  %.4f       %.4f             %.4f\n', ...
            metrics.temp_stability_pid, metrics.temp_stability_fuzzy, metrics.temp_stability_ann);
    fprintf(file_id, 'Integrated Abs Error        %.4f       %.4f             %.4f\n', ...
            metrics.iae_pid, metrics.iae_fuzzy, metrics.iae_ann);
    fprintf(file_id, 'Control Effort              %.4f       %.4f             %.4f\n\n', ...
            metrics.control_effort_pid, metrics.control_effort_fuzzy, metrics.control_effort_ann);
    
    % Determine best controller for each metric
    metrics_fields = fieldnames(metrics);
    controller_names = {'PID', 'Fuzzy Logic', 'ANN'};
    best_controllers = struct();
    
    for i = 1:length(metrics_fields)
        field = metrics_fields{i};
        
        % Skip fields that don't have PID/Fuzzy/ANN variants
        if ~contains(field, '_pid')
            continue;
        end
        
        base_field = strrep(field, '_pid', '');
        values = [metrics.(strcat(base_field, '_pid')), ...
                 metrics.(strcat(base_field, '_fuzzy')), ...
                 metrics.(strcat(base_field, '_ann'))];
        
        % Determine if lower or higher is better (generally lower is better)
        if contains(base_field, 'efficiency') || contains(base_field, 'score')
            [~, best_idx] = max(values);
        else
            [~, best_idx] = min(values);
        end
        
        best_controllers.(base_field) = controller_names{best_idx};
    end
    
    % Write best controller for each metric
    fprintf(file_id, 'Best Controller for Each Metric:\n');
    fprintf(file_id, '-------------------------------\n');
    
    for i = 1:length(metrics_fields)
        field = metrics_fields{i};
        if ~contains(field, '_pid')
            continue;
        end
        
        base_field = strrep(field, '_pid', '');
        readable_name = strrep(base_field, '_', ' ');
        readable_name = [upper(readable_name(1)), readable_name(2:end)];
        
        fprintf(file_id, '%s: %s\n', readable_name, best_controllers.(base_field));
    end
    
    % Close file
    fclose(file_id);
    
    fprintf('Results written to cooling_system_results.txt.\n');
end

%% Main function to run the simulation
function main()
    % Initialize simulation parameters
    [params, time, load_profile, ambient_temp_profile] = initializeSimulation();
    
    % Set up controllers
    pid = setupPIDController();
    fis = setupFuzzyController();
    ann = trainANNController(params);
    
    % Run simulations for each controller
    [T_engine_pid, control_pid, power_consumption_pid] = simulateController('PID', params, time, ...
                                                                         load_profile, ambient_temp_profile, ...
                                                                         pid, fis, ann);
    
    [T_engine_fuzzy, control_fuzzy, power_consumption_fuzzy] = simulateController('Fuzzy', params, time, ...
                                                                                load_profile, ambient_temp_profile, ...
                                                                                pid, fis, ann);
    
    [T_engine_ann, control_ann, power_consumption_ann] = simulateController('ANN', params, time, ...
                                                                          load_profile, ambient_temp_profile, ...
                                                                          pid, fis, ann);
    
    % Calculate performance metrics
    metrics = evaluateExtendedPerformance(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
                                         power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
                                         params.engine.optimal_temp);
    
    % Visualize results
    plotEnhancedResults(time, T_engine_pid, T_engine_fuzzy, T_engine_ann, ...
                       control_pid, control_fuzzy, control_ann, ...
                       power_consumption_pid, power_consumption_fuzzy, power_consumption_ann, ...
                       load_profile, ambient_temp_profile, params, metrics);
    
    % Write results to file
    writeResultsToFile(metrics, params);
end

%% Run the main function
main();